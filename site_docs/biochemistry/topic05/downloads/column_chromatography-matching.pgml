## DESCRIPTION
## Match each of the following types of column chromatography with their corresponding descriptions.
## ENDDESCRIPTION
## KEYWORDS('types of column chromatography','descriptions')
## DBsubject('Laboratory Techniques')
## DBchapter('')
## DBsection('')
## Date('2026-02-25')
## Author('Neil R. Voss')
## Institution('Roosevelt University')

DOCUMENT();

loadMacros(
    'PGstandard.pl',
    'PGML.pl',
    'PGchoicemacros.pl',
    'parserPopUp.pl',
    'parserUtils.pl',
    'PGgraders.pl',
    'PGcourse.pl'
);
our @ALPHABET = ('A' .. 'Z');

# ================================
# Full matching data
# ================================
%match_data = (
  'size-exclusion column (SEC)' => [
    'size <span style="color: #e65400; font-weight:700;">separation</span> in a <span style="color: #e60000; font-weight:700;">column</span> filled with porous beads',
    '<span style="color: #e65400; font-weight:700;">separates</span> molecules by differences in size as they pass through a porous <span style="color: #00b38f; font-weight:700;">particles</span> in a <span style="color: #e60000; font-weight:700;">column</span>',
    'only liquid <span style="color: #b30077; font-weight:700;">chromatography</span> method where molecules do NOT bind to the <span style="color: #b30077; font-weight:700;">chromatography</span> <span style="color: #00b38f; font-weight:700;">particles</span>',
    'ability to separate <span style="color: #00b3b3; font-weight:700;">protein</span>samples by size using porous <span style="color: #00b38f; font-weight:700;">particles</span>',
  ],
  'gel filtration column (GFC)' => [
    'size <span style="color: #e65400; font-weight:700;">separation</span> in a <span style="color: #e60000; font-weight:700;">column</span> filled with porous beads',
    '<span style="color: #e65400; font-weight:700;">separates</span> molecules by differences in size as they pass through a porous <span style="color: #00b38f; font-weight:700;">particles</span> in a <span style="color: #e60000; font-weight:700;">column</span>',
    'only liquid <span style="color: #b30077; font-weight:700;">chromatography</span> method where molecules do NOT bind to the <span style="color: #b30077; font-weight:700;">chromatography</span> <span style="color: #00b38f; font-weight:700;">particles</span>',
    'ability to separate <span style="color: #00b3b3; font-weight:700;">protein</span>samples by size using porous <span style="color: #00b38f; font-weight:700;">particles</span>',
  ],
  'ion exchange column (IEX)' => [
    'separate by charge, <span style="color: #00b38f; font-weight:700;">particle</span>binding is controlled by pH of the solvent mobile phase',
    '<span style="color: #e65400; font-weight:700;">separates</span> <span style="color: #00b3b3; font-weight:700;">proteins</span> with differences in <span style="color: #0a9bf5; font-weight:700;">surface</span> charge',
    '<span style="color: #004d99; font-weight:700;">charged</span> <span style="color: #00b3b3; font-weight:700;">proteins</span> interact with an oppositely <span style="color: #004d99; font-weight:700;">charged</span> <span style="color: #b30077; font-weight:700;">chromatography</span> <span style="color: #00b38f; font-weight:700;">particle</span>resin',
    'above its isoelectric point (pI), a <span style="color: #00b3b3; font-weight:700;">protein</span>will bind to a positively <span style="color: #004d99; font-weight:700;">charged</span> anion exchanger',
    'below its isoelectric point (pI), a <span style="color: #00b3b3; font-weight:700;">protein</span>will bind to a negatively <span style="color: #004d99; font-weight:700;">charged</span> cation exchanger',
    '<span style="color: #e65400; font-weight:700;">separation</span> method essentially based on the net charge of the protein',
    'relies on charge-charge interactions between the <span style="color: #00b3b3; font-weight:700;">proteins</span> in your sample and the charges on the <span style="color: #00b38f; font-weight:700;">particle</span>resin',
  ],
  'hydrophobic interaction column (HIC)' => [
    '<span style="color: #e65400; font-weight:700;">separates</span> by <span style="color: #0a9bf5; font-weight:700;">surface</span> hydrophobicity, <span style="color: #00b38f; font-weight:700;">particle</span>binding is controlled by salt concentration and/or organic solvents',
    '<span style="color: #e65400; font-weight:700;">separates</span> <span style="color: #00b3b3; font-weight:700;">proteins</span> according to differences in their <span style="color: #0a9bf5; font-weight:700;">surface</span> hydrophobicity',
    'hydrophobic-based <span style="color: #e65400; font-weight:700;">separation</span>s for <span style="color: #00b3b3; font-weight:700;">protein</span>characterization',
    'for one type, high salt concentration enhances the interaction, whereas low salt concentrations weaken it',
    'for one type, a decreasing salt gradient is used to separate samples in order of increasing hydrophobicity',
    'technique based on the ability to separate <span style="color: #00b3b3; font-weight:700;">proteins</span> based on relative hydrophobic differences',
    'for one type, gradients of increasing organic solvent concentration are used to affect <span style="color: #e65400; font-weight:700;">separation</span>s',
  ],
  'reverse phase column (RPC)' => [
    '<span style="color: #e65400; font-weight:700;">separates</span> by <span style="color: #0a9bf5; font-weight:700;">surface</span> hydrophobicity, <span style="color: #00b38f; font-weight:700;">particle</span>binding is controlled by salt concentration and/or organic solvents',
    '<span style="color: #e65400; font-weight:700;">separates</span> <span style="color: #00b3b3; font-weight:700;">proteins</span> according to differences in their <span style="color: #0a9bf5; font-weight:700;">surface</span> hydrophobicity',
    'hydrophobic-based <span style="color: #e65400; font-weight:700;">separation</span>s for <span style="color: #00b3b3; font-weight:700;">protein</span>characterization',
    'for one type, high salt concentration enhances the interaction, whereas low salt concentrations weaken it',
    'for one type, a decreasing salt gradient is used to separate samples in order of increasing hydrophobicity',
    'technique based on the ability to separate <span style="color: #00b3b3; font-weight:700;">proteins</span> based on relative hydrophobic differences',
    'for one type, gradients of increasing organic solvent concentration are used to affect <span style="color: #e65400; font-weight:700;">separation</span>s',
  ],
  'affinity column (AC)' => [
    '<span style="color: #e65400; font-weight:700;">separation</span> based on <span style="color: #00b3b3; font-weight:700;">proteins</span> binding to a <span style="color: #7b12a1; font-weight:700;">ligand</span>',
    '<span style="color: #e65400; font-weight:700;">separates</span> <span style="color: #00b3b3; font-weight:700;">proteins</span> on the basis of a reversible interaction between the target <span style="color: #00b3b3; font-weight:700;">protein</span>and a specific <span style="color: #7b12a1; font-weight:700;">ligand</span>',
    'works using resin-attached <span style="color: #7b12a1; font-weight:700;">ligand</span>s to grab hold of the corresponding <span style="color: #00b3b3; font-weight:700;">proteins</span>',
    'a specific <span style="color: #7b12a1; font-weight:700;">ligand</span> is attached to the <span style="color: #00b38f; font-weight:700;">particle</span>resin in the <span style="color: #e60000; font-weight:700;">column</span>',
    'relies on the specific and reversible binding of a <span style="color: #00b3b3; font-weight:700;">protein</span>to a matrix-bound <span style="color: #7b12a1; font-weight:700;">ligand</span>',
    '<span style="color: #7b12a1; font-weight:700;">ligand</span>-attached beads bind directly to the <span style="color: #00b3b3; font-weight:700;">protein</span>of interest',
  ],
);

# -------------------------------
# Exclude pairs
# -------------------------------
@exclude_pairs = (
  ['size-exclusion column (SEC)', 'gel filtration column (GFC)'],
  ['hydrophobic interaction column (HIC)', 'reverse phase column (RPC)'],
);

# -------------------------------
# Select N random keys
# -------------------------------
my $n = 4;
@all_keys = PGsort(sub { $_[0] lt $_[1] }, keys %match_data);
my $local_seed = (defined($problemSeed) && $problemSeed ne '') ? $problemSeed : 1;
my $local_random = new PGrandom($local_seed);

my @selected_keys = ();
my $max_tries = 500;
my $tries = 0;
while (1) {
  my @indices = (0 .. $#all_keys);
  my @shuffled = ();
  while (@indices) {
    my $pick = $local_random->random(0, $#indices, 1);
    push @shuffled, splice(@indices, $pick, 1);
  }
  @selected_keys = @all_keys[@shuffled[0..$n-1]];
  my %selected = map { $_ => 1 } @selected_keys;
  my $excluded = 0;
  foreach my $pair (@exclude_pairs) {
    my ($left, $right) = @$pair;
    if ($selected{$left} && $selected{$right}) {
      $excluded = 1;
      last;
    }
  }
  last if !$excluded;
  $tries += 1;
  if ($tries > $max_tries) {
    die 'Unable to find a non-conflicting set of keys';
  }
}

# -------------------------------
# Build question/answer pairs
# -------------------------------
# Each entry: [prompt, choice]
@q_and_a = ();
foreach my $key (@selected_keys) {
  my $values_ref = $match_data{$key};
  my $i = $local_random->random(0, $#$values_ref, 1);
  my $value = $values_ref->[$i];
  push @q_and_a, [ $value, $key ];
}

# -------------------------------
# Randomize the questions
# -------------------------------
my @q_indices = (0 .. $#q_and_a);
my @q_shuffled = ();
while (@q_indices) {
  my $pick = $local_random->random(0, $#q_indices, 1);
  push @q_shuffled, $q_and_a[splice(@q_indices, $pick, 1)];
}
@q_and_a = @q_shuffled;

# -------------------------------
# Sort the choices alphabetically
# -------------------------------
@answers = ();
push(@answers, (map { $_->[1] } @q_and_a));
@answers_sorted = PGsort(sub { $_[0] lt $_[1] }, @answers);

# -------------------------------
# HTML-safe answer labels
# -------------------------------
%answer_html = (
  'size-exclusion column (SEC)' => '<span style="color: #009900; font-weight:700;">size-exclusion column (SEC)</span>',
  'gel filtration column (GFC)' => '<span style="color: #59b300; font-weight:700;">gel filtration column (GFC)</span>',
  'ion exchange column (IEX)' => '<span style="color: #0039e6; font-weight:700;">ion exchange column (IEX)</span>',
  'hydrophobic interaction column (HIC)' => '<span style="color: #b3b300; font-weight:700;">hydrophobic interaction column (HIC)</span>',
  'reverse phase column (RPC)' => '<span style="color: #e69100; font-weight:700;">reverse phase column (RPC)</span>',
  'affinity column (AC)' => '<span style="color: #cc0066; font-weight:700;">affinity column (AC)</span>',
);

@answers_sorted_html = map { $answer_html{$_} || $_ } @answers_sorted;

# -------------------------------
# Create answer index lookup
# -------------------------------
our %answer_index;
for (my $i = 0; $i <= $#answers_sorted; $i++) {
  $answer_index{$answers_sorted[$i]} = $i;
}

# -------------------------------
# PopUp/DropDown compatibility
# -------------------------------
sub make_popup {
  return defined &DropDown ? DropDown(@_) : PopUp(@_);
}

# -------------------------------
# Create popup objects (blank default)
# -------------------------------
my @answer_letters = @ALPHABET[0 .. $#answers_sorted];
my @answer_letters_with_blank = ('', @answer_letters);
@answer_dropdowns =
  map { make_popup([ @answer_letters_with_blank ], $answer_index{$q_and_a[$_][1]} + 1 ) }
  0 .. $#q_and_a;

# -------------------------------
# Render the question
# -------------------------------
HEADER_TEXT(<<END_STYLE);
<style>
.pgml-bold { font-weight: 700; }
.two-column {
    display: flex;
	flex-wrap: wrap;
	gap: 2rem;
	align-items: center;
	justify-content: space-evenly;
}
</style>
END_STYLE

BEGIN_PGML
Match each of the following types of column chromatography with their corresponding descriptions.
Note: Each choice will be used exactly once.

[@ MODES(HTML => '<div class="two-column"><div>') @]*
[@ join(
    "\n\n",
    map {
        '[_]{$answer_dropdowns[' . $_ . ']} '
            . '*' . ($_ + 1) . '.* '
            . '[$q_and_a[' . $_ . '][0]]*'
    } 0 .. $#q_and_a
) @]**
[@ MODES(HTML => '</div><div class="right-col">') @]*
[@ join(
    "\n\n",
    map {
        chr(65 + $_) . '\\.' . ' ' . '[$answers_sorted_html[' . $_ . ']]*'
    } 0 .. $#answers_sorted
) @]**
[@ MODES(HTML => '</div></div>') @]*
END_PGML

# -------------------------------
# Dynamic Partial Credit Based on $n
# -------------------------------
$showPartialCorrectAnswers = 0;
my @thresholds;
my @scores;
for (my $i = 1; $i <= $n; $i++) {
  push @thresholds, $i;
  push @scores, sprintf("%.2f", $i / $n);
}

install_problem_grader(~~&custom_problem_grader_fluid);
$ENV{grader_numright} = [@thresholds];
$ENV{grader_scores}   = [@scores];
$ENV{grader_message} = 'You can earn partial credit.';

# -------------------------------
# Solution
# -------------------------------
$answer_list = join(', ', map { ($_ + 1) . '-' . $ALPHABET[$answer_index{$q_and_a[$_][1]}] } 0 .. $#q_and_a);
BEGIN_PGML_SOLUTION
The correct answers are: [$answer_list].
END_PGML_SOLUTION

ENDDOCUMENT();

